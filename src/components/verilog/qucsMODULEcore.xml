<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.2.4" xmlns:admst="http://mot-adms.sourceforge.net/xml-files/admst">

<!-- handling of device: starting point -->
<admst:for-each select="/module">
<!-- definition of variables -->
<admst:value-of select="name"/>
<admst:variable name="module" select="%s"/>
<admst:count select="node[name!='GND']"/>
<admst:variable name="nbr_nodes" select="%s"/>
<admst:count select="source[whitenoise='yes']"/>
<admst:variable name="nbr_sources_whitenoise" select="%s"/>
<admst:count select="source[flickernoise='yes']"/>
<admst:variable name="nbr_sources_flickernoise" select="%s"/>
</admst:for-each>

<admst:open file="$module.cpp">
/*
 * $(module).cpp - device implementations for $(module) module
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 */
<admst:for-each select="/module">

#if HAVE_CONFIG_H
<admst:text format="#include &lt;config.h&gt;"/>
#endif

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

<admst:text format="#include &quot;$(module)_analogfunction.h&quot;\n"/>
#include "logging.h"
#include "complex.h"
#include "matrix.h"
#include "object.h"
#include "node.h"
#include "circuit.h"
#include "net.h"
#include "component_id.h"
#include "constants.h"
#include "device.h"
<admst:text format="#include &quot;$module.h&quot;\n\n"/>
<admst:text format="// external nodes\n"/>
<admst:for-each select="node">
  <admst:if test="[location='external' and name!='GND']">
  <admst:value-of select="name"/>
  <admst:text format="#define %s"/>
  <admst:value-of select="position(.)-2"/>
  <admst:text format=" %s\n"/>
  </admst:if> 
</admst:for-each>
<admst:text format="// internal nodes\n"/>
<admst:for-each select="node"> 
  <admst:if test="[location='internal' and name!='GND']">
  <admst:value-of select="name"/>
  <admst:text format="#define %s"/>
  <admst:value-of select="position(.)-2"/>
  <admst:text format=" %s\n"/>
  </admst:if>
</admst:for-each>

<admst:text format="\n// useful macro definitions"/>
#define NP(node) real(getV(node))
#define BP(pnode,nnode) real(getV(pnode)-getV(nnode))
#define _load_static_residual2(pnode,nnode,current)\\
	_rhs[pnode] -= current;\\
	_rhs[nnode] += current;
#define _load_static_residual1(node,current)\\
	_rhs[node] -= current;	
#define _load_static_jacobian4(pnode,nnode,vpnode,vnnode,conductance)\\
	_jstat[pnode][vpnode] += conductance; \\
	_jstat[nnode][vnnode] += conductance; \\
	_jstat[pnode][vnnode] -= conductance; \\
	_jstat[nnode][vpnode] -= conductance; \\
	_rhs[pnode] += conductance * BP(vpnode,vnnode); \\
	_rhs[nnode] -= conductance * BP(vpnode,vnnode);	
#define _load_static_jacobian2p(node,vpnode,vnnode,conductance)\\
	_jstat[node][vpnode] += conductance;\\
	_jstat[node][vnnode] -= conductance;\\
        _rhs[node] += conductance*(BP(vpnode,vnnode));
#define _load_static_jacobian2s(pnode,nnode,node,conductance)\\
	_jstat[pnode][node] += conductance;\\
	_jstat[nnode][node] -= conductance;\\
	_rhs[pnode] += conductance * NP(node);\\
	_rhs[nnode] -= conductance * NP(node);
#define _load_static_jacobian1(node,vnode,conductance)\\
	_jstat[node][vnode] += conductance;\\
	_rhs[node] += conductance * NP(vnode);
#define _load_dynamic_residual2(pnode,nnode,current)\\
	if (doTR) _charges[pnode][nnode] += current;
#define _load_dynamic_residual1(node,current)\\
	if (doTR) _charges[node][<admst:text format="$nbr_nodes"/>] += current;
#define _load_dynamic_jacobian4(pnode,nnode,vpnode,vnnode, conductance)\\
	if (doAC) {\\
	_jdyna[pnode][vpnode] += conductance;\\
	_jdyna[nnode][vnnode] += conductance;\\
	_jdyna[pnode][vnnode] -= conductance;\\
	_jdyna[nnode][vpnode] -= conductance;\\
	}\\
        if (doTR) {\\
        _caps[pnode][nnode][vpnode][vnnode] += conductance;\\
  	}
#define _load_dynamic_jacobian2s(pnode,nnode,vnode,conductance)\\
	if (doAC) {\\
	_jdyna[pnode][vnode] += conductance;\\
	_jdyna[nnode][vnode] -= conductance;\\
	}\\
	if (doTR) {\\
	_caps[pnode][nnode][vnode][<admst:text format="$nbr_nodes"/>] += conductance;\\
	}	
#define _load_dynamic_jacobian2p(node,vpnode,vnnode,conductance)\\
	if (doAC) {\\
	_jdyna[node][vpnode] += conductance;\\
        _jdyna[node][vnnode] -= conductance;\\
        }\\
	if (doTR) {\\
        _caps[node][<admst:text format="$nbr_nodes"/>][vpnode][vnnode] += conductance;\\
	}
#define _load_dynamic_jacobian1(node,vnode,conductance)\\
	if (doAC) {\\
	_jdyna[node][vnode] += conductance;\\
	}\\
	if (doTR) {\\
	_caps[node][<admst:text format="$nbr_nodes"/>][vnode][<admst:text format="$nbr_nodes"/>] += conductance;\\
	}

#define _save_whitenoise1(n1,pwr,type)\\
	_white_pwr[n1][n1] += pwr;
#define _save_whitenoise2(n1,n2,pwr,type)\\
	_white_pwr[n1][n2] += pwr;
#define _save_flickernoise1(n1,pwr,exp,type)\\
	_flicker_pwr[n1][n1] += pwr;\\
	_flicker_exp[n1][n1] += exp;
#define _save_flickernoise2(n1,n2,pwr,exp,type)\\
	_flicker_pwr[n1][n2] += pwr;\\
	_flicker_exp[n1][n2] += exp;
#define _load_whitenoise2(n1,n2,pwr)\\
	cy (n1,n2) -= pwr/kB/T0; cy (n2,n1) -= pwr/kB/T0;\\
	cy (n1,n1) += pwr/kB/T0; cy (n2,n2) += pwr/kB/T0;
#define _load_whitenoise1(n1,pwr)\\
	cy (n1,n1) += pwr/kB/T0;
#define _load_flickernoise2(n1,n2,pwr,exp)\\
	cy (n1,n2) -= pwr*pow(_freq,-exp)/kB/T0;\\
	cy (n2,n1) -= pwr*pow(_freq,-exp)/kB/T0;\\
	cy (n1,n1) += pwr*pow(_freq,-exp)/kB/T0;\\
	cy (n2,n2) += pwr*pow(_freq,-exp)/kB/T0;
#define _load_flickernoise1(n1,pwr,exp)\\
	cy (n1,n1) += pwr*pow(_freq,-exp)/kB/T0;

<admst:text format="// derivative helper macros"/>
<admst:apply-templates select="." match="c:math_h"/>

<admst:text format="\n// \$vt and \$vt() functions "/>
#define _vt(arg)                 (kBoverQ*arg)
#define _vt_nom                  (kBoverQ)

<admst:text format="\n// simulator specific definitions"/>
#define _modelname               &quot;$(module)&quot;
#define _instancename            getName()
#define _circuit_temp		 (getPropertyDouble (&quot;Temp&quot;)+273.15)

using namespace device;

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Device constructor. */\n"/>
<admst:text format="$module::$module() : circuit ($nbr_nodes)\n{\n"/>
<admst:text format="  type = CIR_$module;\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of model. */\n"/>
<admst:text format="void $module::initModel (void)\n{"/>
  // create internal nodes
<admst:for-each select="node">
  <admst:if test="[location='internal' and name!='GND']">
  <admst:value-of select="name"/>
  <admst:value-of select="name"/>  
  <admst:text format="  setNode(%s, createInternal (getName (), &quot;%s&quot;));\n"/>
  </admst:if>
</admst:for-each>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of DC analysis. */\n"/>
<admst:text format="void $module::initDC (void)\n{"/>
  allocMatrixMNA ();
  initModel ();
  char * type = getPropertyString ("Type");
  pol = (type != NULL &amp;&amp; !strcmp (type, "pnp")) ? -1 : 1;
  restartDC ();
  doAC = 1;
  doTR = 0;
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Run when DC is restarted (fallback algorithms). */\n"/>
<admst:text format="void $module::restartDC (void)\n{\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform DC iteration. */\n"/>
<admst:text format="void $module::calcDC (void)\n{\n"/>
		
<admst:text format="  // get device model parameters\n"/>
<admst:for-each select="variable">
  <admst:if test="[input='yes']">
    <admst:value-of select="name"/>
    <admst:value-of select="name"/>    
    <admst:text format="  nr_double_t %s = getPropertyDouble (&quot;%s&quot;);\n"/> 
  </admst:if>
</admst:for-each>

<admst:text format="\n  // definition of derivative helper variables"/>
  nr_double_t __log_0, __d_log_0, __log_1, __d_log_1, __log_2, __d_log_2;
  nr_double_t __exp_0, __d_exp_0, __exp_1, __d_exp_1, __exp_2, __d_exp_2;
  nr_double_t __sqrt_0, __d_sqrt_0, __sqrt_1, __d_sqrt_1, __sqrt_2, __d_sqrt_2;
  nr_double_t __limexp_0, __d_limexp_0, __limexp_1, __d_limexp_1;
  nr_double_t __limexp_2, __d_limexp_3, __tanh_0, __d_tanh_0;
  nr_double_t __fabs_0, __d_fabs_0, __fabs_1, __d_fabs_1, __fabs_2, __d_fabs_2;
  nr_double_t __pow_0, __dFx_pow_0, __pow_1, __dFx_pow_1, __pow_2, __dFx_pow_2;

<admst:text format="  // initialization of noise variables\n"/>
<admst:for-each select="source[whitenoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  _white_pwr[$pnode][$nnode] = 0.0;\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  _white_pwr[$pnode][$pnode] = 0.0;\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:for-each select="source[flickernoise='yes']">
  <admst:value-of select="branch/nnode/name" />
  <admst:value-of select="branch/pnode/name" />
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  _flicker_pwr[$pnode][$nnode] = 0.0;\n" />
    <admst:text format="  _flicker_exp[$pnode][$nnode] = 0.0;\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  _flicker_pwr[$pnode][$pnode] = 0.0;\n" />
    <admst:text format="  _flicker_exp[$pnode][$pnode] = 0.0;\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
  int i1, i2, i3, i4;

  // zero charges
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes + 1; i2++) {\n"/>
<admst:text format="    _charges[i1][i2] = 0.0;\n"/>
<admst:text format="  } }\n"/>
  // zero capacitances
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes + 1; i2++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="  for (i4 = 0; i4 < $nbr_nodes; i4++) {\n"/>
<admst:text format="    _caps[i1][i2][i3][i4] = 0.0;\n"/>
<admst:text format="  } } } }"/>
  // zero right hand side, static and dynamic jacobian
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    _rhs[i1] = 0.0;\n"/>
<admst:text format="    for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      _jstat[i1][i2] = 0.0;\n"/>
<admst:text format="      _jdyna[i1][i2] = 0.0;\n"/>
<admst:text format="    }\n  }\n"/>

/* ----------------- evaluate verilog analog equations -------------------- */
<admst:apply-templates select="analog" match="analog:evaluate"/>
/* ------------------ end of verilog analog equations --------------------- */

/* ------------------ evaluate verilog noise equations -------------------- */
<admst:apply-templates select="analog" match="analog:noise" required="yes"/>
/* ------------------- end of verilog noise equations --------------------- */

  // fill right hand side and static jacobian
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    setI (i1, _rhs[i1]);\n"/>
<admst:text format="    for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      setY (i1, i2, _jstat[i1][i2]);\n"/>
<admst:text format="    }\n  }\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Save operating points. */\n"/>
<admst:text format="void $module::saveOperatingPoints (void)\n{\n"/>
<admst:text format="#if DEBUG\n"/>

<admst:for-each select="node">
<admst:if test="[name!='GND']">
  <admst:value-of select="name"/>
  <admst:variable name="node1" select="%s"/>
    <admst:for-each select="../node">
      <admst:if test="[name!='GND']">
      <admst:value-of select="name"/>
      <admst:variable name="node2" select="%s"/>      
      <admst:text format="  setOperatingPoint (&quot;jstat[$node1][$node2]&quot;, _jstat[$node1][$node2]);\n"/>
      <admst:text format="  setOperatingPoint (&quot;jdyna[$node1][$node2]&quot;, _jdyna[$node1][$node2]);\n"/>
      </admst:if> 
    </admst:for-each>
</admst:if> 
</admst:for-each>

<admst:for-each select="source[whitenoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  setOperatingPoint (&quot;white_pwr[$pnode][$nnode]&quot;, _white_pwr[$pnode][$nnode]);\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  setOperatingPoint (&quot;white_pwr[$pnode][$pnode]&quot;, _white_pwr[$pnode][$pnode]);\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>

<admst:for-each select="source[flickernoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  setOperatingPoint (&quot;flicker_pwr[$pnode][$nnode]&quot;, _flicker_pwr[$pnode][$nnode]);\n" />
  </admst:when>
  <admst:otherwise>
    <admst:text format="  setOperatingPoint (&quot;flicker_pwr[$pnode][$pnode]&quot;, _flicker_pwr[$pnode][$pnode]);\n" />
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:text format="#endif /* DEBUG */\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Load operating points. */\n"/>
<admst:text format="void $module::loadOperatingPoints (void)\n{\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Calculate operating points. */\n"/>
<admst:text format="void $module::calcOperatingPoints (void)\n{\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of AC analysis. */\n"/>
<admst:text format="void $module::initAC (void)\n{"/>
  allocMatrixMNA ();
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform AC calculations. */\n"/>
<admst:text format="void $module::calcAC (nr_double_t frequency)\n{"/>
  setMatrixY (calcMatrixY (frequency));
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Compute Y-matrix for AC analysis. */\n"/>
<admst:text format="matrix $module::calcMatrixY (nr_double_t frequency)\n{"/>
  _freq = frequency;
  saveOperatingPoints ();
  matrix y ($nbr_nodes);

<admst:text format="  for (int i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    for (int i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="      y (i1,i2) = rect (_jstat[i1][i2], _jdyna[i1][i2] * 2 * M_PI * _freq);\n"/>
<admst:text format="    }\n  }\n"/>
  return y;
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of S-parameter analysis. */\n"/>
<admst:text format="void $module::initSP (void)\n{"/>
  allocMatrixS ();
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform S-parameter calculations. */\n"/>
<admst:text format="void $module::calcSP (nr_double_t frequency)\n{"/>
  setMatrixS (ytos (calcMatrixY (frequency)));   
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Initialization of transient analysis. */\n"/>
<admst:text format="void $module::initTR (void)\n{"/>
  setStates (2*$nbr_nodes*$nbr_nodes+2*$nbr_nodes);
  initDC ();
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform transient analysis iteration step. */\n"/>
<admst:text format="void $module::calcTR (nr_double_t)\n{"/>
  doAC = 1;
  doTR = 1;
  calcDC ();

  int i1, i2, i3, i4, state;

  // 2-node charge integrations
<admst:text format="  for (i1 = 0;i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="    state = 2*(i1+i2+($nbr_nodes-1)*i1);\n"/>
<admst:text format="    if (_charges[i1][i2] != 0.0)\n"/>
<admst:text format="      transientCapacitanceQ (state, i1, i2, _charges[i1][i2]);\n"/>
<admst:text format="  } }\n"/>
  // 1-node charge integrations
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="    state = 2*(i1+$nbr_nodes+($nbr_nodes-1)*i1+1);\n"/>
<admst:text format="    if (_charges[i1][$nbr_nodes] != 0.0)\n"/>
<admst:text format="      transientCapacitanceQ (state, i1, _charges[i1][$nbr_nodes]);\n"/>
<admst:text format="  }\n"/> 
  // charge: 2-node, voltage: 2-node
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="  for (i4 = 0; i4 < $nbr_nodes; i4++) {\n"/>
<admst:text format="    if (_caps[i1][i2][i3][i4] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC (i1, i2, i3, i4, _caps[i1][i2][i3][i4], BP(i3,i4));\n"/>
<admst:text format="  } } } }\n"/>               
  // charge: 2-node, voltage: 1-node
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i2 = 0; i2 < $nbr_nodes; i2++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="    if (_caps[i1][i2][i3][$nbr_nodes] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC2Q (i1, i2, i3, _caps[i1][i2][i3][$nbr_nodes], NP(i3));\n"/>
<admst:text format="  } } }\n"/>     
  // charge: 1-node, voltage: 2-node
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>
<admst:text format="  for (i4 = 0; i4 < $nbr_nodes; i4++) {\n"/>
<admst:text format="    if (_caps[i1][$nbr_nodes][i3][i4] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC2V (i1, i2, i3, _caps[i1][$nbr_nodes][i3][i4], BP(i3,i4));\n"/>
<admst:text format="  } } }\n"/>     
  // charge: 1-node, voltage: 1-node
<admst:text format="  for (i1 = 0; i1 < $nbr_nodes; i1++) {\n"/>
<admst:text format="  for (i3 = 0; i3 < $nbr_nodes; i3++) {\n"/>               
<admst:text format="    if (_caps[i1][$nbr_nodes][i3][$nbr_nodes] != 0.0)\n"/>
<admst:text format="      transientCapacitanceC (i1, i3, _caps[i1][$nbr_nodes][i3][$nbr_nodes], NP(i3));\n"/>
<admst:text format="  } }\n"/> 
  
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Compute Cy-matrix for AC noise analysis. */\n"/>
<admst:text format="matrix $module::calcMatrixCy (nr_double_t frequency) \n{"/>
  _freq = frequency;
  matrix cy ($nbr_nodes);

<admst:for-each select="source[flickernoise='yes']">
  <admst:value-of select="branch/nnode/name"/>
  <admst:value-of select="branch/pnode/name"/>
  <admst:variable name="pnode" select="%s"/>
  <admst:variable name="nnode" select="%s"/>
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:text format="  _load_flickernoise2 ($pnode,$nnode,_flicker_pwr[$pnode][$nnode],_flicker_exp[$pnode][$nnode]);\n"/>
  </admst:when>
  <admst:otherwise>
    <admst:text format="  _load_flickernoise1 ($pnode,_flicker_pwr[$pnode][$pnode],_flicker_exp[$pnode][$pnode]);\n"/>
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:for-each select="source[whitenoise='yes']">
  <admst:choose>
  <admst:when test="branch/nnode[grounded='no']">
    <admst:value-of select="branch/nnode/name"/>
    <admst:value-of select="branch/pnode/name"/>
    <admst:variable name="pnode" select="%s"/>
    <admst:variable name="nnode" select="%s"/>
    <admst:text format="  _load_whitenoise2 ($pnode,$nnode,_white_pwr[$pnode][$nnode]);\n"/>
  </admst:when>
  <admst:otherwise>
    <admst:value-of select="branch/nnode/name"/>
    <admst:value-of select="branch/pnode/name"/>
    <admst:variable name="pnode" select="%s"/>
    <admst:variable name="nnode" select="%s"/>
    <admst:text format="  _load_whitenoise1 ($pnode,_white_pwr[$pnode][$pnode]);\n"/>
  </admst:otherwise>
  </admst:choose>
</admst:for-each>
<admst:text format="\n  return cy;\n"/>
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform AC noise computations. */\n"/>
<admst:text format="void $module::calcNoiseAC (nr_double_t frequency) \n{"/>
  setMatrixN (calcMatrixCy (frequency));
<admst:text format="}\n\n"/>

<!-- ---------------------------------------------------------------------- -->

<admst:text format="/* Perform S-parameter noise computations. */\n"/>
<admst:text format="void $module::calcNoiseSP (nr_double_t frequency) \n{"/>
  setMatrixN (cytocs (calcMatrixCy (frequency) * z0, getMatrixS ()));
<admst:text format="}\n\n"/>

</admst:for-each>

</admst:open>

<admst:open file="$module.h">
/*
 * $(module).h - device class definitions for $(module) module
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 */
<admst:for-each select="/module">

#ifndef __<admst:text format="$module"/>_H__
#define __<admst:text format="$module"/>_H__

<admst:text format="class $module : public circuit"/>
{
 public:
  <admst:text format="$module ();\n"/>
  void initDC (void);
  void restartDC (void);
  void calcDC (void);
  void saveOperatingPoints (void);
  void loadOperatingPoints (void);
  void calcOperatingPoints (void);
  void initAC (void);
  void calcAC (nr_double_t);
  void initSP (void);
  void calcSP (nr_double_t);
  void calcNoiseAC (nr_double_t);
  void calcNoiseSP (nr_double_t);
  void initTR (void);
  void calcTR (nr_double_t);
  void initModel (void);
  matrix calcMatrixY (nr_double_t);
  matrix calcMatrixCy (nr_double_t);
  
 private:
  int doAC;
  int doTR;

  nr_double_t _freq;
<admst:text format="  nr_double_t _rhs[$nbr_nodes];\n"/> 
<admst:text format="  nr_double_t _jstat[$nbr_nodes][$nbr_nodes];\n"/>
<admst:text format="  nr_double_t _jdyna[$nbr_nodes][$nbr_nodes];\n"/>
<admst:text format="  nr_double_t _white_pwr[$nbr_nodes][$nbr_nodes];\n"/>
<admst:text format="  nr_double_t _flicker_pwr[$nbr_nodes][$nbr_nodes];\n"/>
<admst:text format="  nr_double_t _flicker_exp[$nbr_nodes][$nbr_nodes];\n"/>
<admst:text format="  nr_double_t _charges[$nbr_nodes][$nbr_nodes+1];\n"/>
<admst:text format="  nr_double_t _caps[$nbr_nodes][$nbr_nodes+1][$nbr_nodes][$nbr_nodes+1];"/>
};

#endif /* __<admst:text format="$module"/>_H__ */

</admst:for-each>

</admst:open>

<admst:message format="$module.cpp and $module.h: files created\n"/>

</admst>
