//   Qucs EPFL-EKV 2.6 pMOS model:
//
//   The structure and theoretical background to the EKV 2.6
//   Verilog-a model is presented in the Qucs EPL-EKV 2.6 report.
//   Typical parameters are for 0.5um CMOS (C) EPLFL-LEG 1999.
//   Geometry range: Short channel: W >= 0.8um, L >= 0.5um
//                   Long channel:  W >= 2um,   L >= 2um
//   Voltage range:  |Vgb| < 3.3V, |Vdb| < 3.3V, |Vsb| < 2V
//
//   This is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2, or (at your option)
//   any later version.
// 
//   Copyright (C), Mike Brinson, mbrin72043@yahoo.co.uk, May 2008.
//
`include "disciplines.vams"
`include "constants.vams"

// 
 module EKV26pMOS (Drain, Gate, Source, Bulk);
 inout Drain, Gate, Source, Bulk;
electrical Drain, Gate, Source, Bulk;
// Internal nodes
electrical Drain_int, Source_int;
`define attr(txt) (*txt*)
// Device dimension parameters
 parameter real LEVEL = 1 from [1 : 2]  `attr(info="long = 1, short = 2");
 parameter real L = 0.5e-6 from [0.0 : inf]  `attr(info="length parameter" unit = "m" );
 parameter real W = 10e-6 from [0.0 : inf]  `attr(info="Width parameter" unit = "m"); 
 parameter real Np = 1.0 from [1.0 : inf]   `attr(info="parallel multiple device number");
 parameter real Ns = 1.0 from [1.0 : inf] `attr(info="series multiple device number"); 
// Process parameters
 parameter real Cox = 3.45e-3 from [0 : inf]         `attr(info="gate oxide capacitance per unit area" unit = "F/m**2" );
 parameter real Xj = 0.15e-6 from [0.01e-6 : 1.0e-6] `attr(info="metallurgical junction depth" unit = "m");
 parameter real Dw = -0.03e-6 from [-inf : 0.0]      `attr(info="channel width correction" unit = "m");
 parameter real Dl = -0.05e-6 from [-inf : 0.0]       `attr(info="channel length correction" unit = "m");
// Basic intrinsic model parameters
 parameter real Vto = -0.55 from [-inf : -1e-6]     `attr(info="long channel threshold voltage" unit="V" );
 parameter real Gamma = 0.69 from [0.0 : 2.0]       `attr(info="body effect parameter" unit="V**(1/2)");
 parameter real Phi = 0.87 from [0.3 : 2.0]         `attr(info="bulk Fermi potential" unit="V");
 parameter real Kp = 35e-6 from [10e-6 : inf]      `attr(info="transconductance parameter" unit = "A/V**2");
 parameter real Theta = 50e-3 from [0.0 : inf]      `attr(info="mobility reduction coefficient" unit = "1/V");
 parameter real EO = 51.0e6 from [1.0e6 : inf]      `attr(info="mobility coefficient" unit="V/m");
 parameter real Ucrit = 18.0e6 from [2.0e6 : 25.0e6] `attr(info="longitudinal critical field" unit="V/m");
// Channel length and charge sharing parameters
 parameter real Lambda = 1.1 from [0.1 : inf]      `attr(info="depletion length coefficient");
 parameter real Weta = 0.0  from [0.0 : inf]        `attr(info="narrow-channel effect coefficient");
 parameter real Leta = 0.45 from [0.0 : inf]        `attr(info="longitudinal critical field");
// Reverse short channel effect parameters
 parameter real Q0 = 200e-6 from [0.0 : inf]        `attr(info="reverse short channel charge density" unit="A*s/m**2");
 parameter real Lk = 0.6e-6 from [0.0 : inf]        `attr(info="characteristic length" unit="m");
// Intrinsic model temperature parameters
 parameter real Tcv = -1.4e-3   `attr(info="threshold voltage temperature coefficient" unit="V/K");
 parameter real Bex = -1.4     `attr(info="mobility temperature coefficient");
 parameter real Ucex = 2.0     `attr(info="Longitudinal critical field temperature exponent");
 parameter real Ibbt = 0.0     `attr(info="Ibb temperature coefficient" unit = "1/K");
// Series resistance calculation parameters
 parameter real Hdif = 0.9e-6 from [0.0 :inf]  `attr(info="heavily doped diffusion length" unit = "m");
 parameter real Rsh = 990.0 from [0.0 : inf]   `attr(info="drain/source diffusion sheet resistance" unit="Ohm/square");
 parameter real Rsc = 0.0 from [0.0 : inf]     `attr(info="source contact resistance" unit="Ohm");
 parameter real Rdc = 0.0 from [0.0 : inf]     `attr(info="drain contact resistance" unit="Ohm");
// Gate overlap capacitances
 parameter real Cgso = 1.5e-10 from [0.0 :inf]  `attr(info="gate to source overlap capacitance" unit = "F/m");
 parameter real Cgdo = 1.5e-10 from [0.0 : inf] `attr(info="gate to drain overlap capacitance"  unit=  "F/m");
 parameter real Cgbo = 4.0e-10 from [0.0 : inf] `attr(info="gate to bulk overlap capacitance"   unit=  "F/m");
// Impact ionization related parameters
 parameter real Iba = 0.0 from [0.0 :inf]        `attr(info="first impact ionization coefficient" unit = "1/m");
 parameter real Ibb = 3.0e8 from [1.0e8 : inf]   `attr(info="second impact ionization coefficient" unit="V/m");
 parameter real Ibn = 1.0 from [0.1 : inf]       `attr(info="saturation voltage factor for impact ionization");
// Flicker noise parameters
 parameter real Kf = 1.0e-28 from [0.0 :inf]  `attr(info="flicker noise coefficient");
 parameter real Af = 1.0 from [0.0 : inf]     `attr(info="flicker noise exponent" );
// Matching parameters
 parameter real Avto = 0.0 from [0.0 :inf]     `attr(info="area related theshold voltage mismatch parameter" unit = "V*m");
 parameter real Akp = 0.0 from [0.0 : inf]     `attr(info="area related gain mismatch parameter" unit="m");
 parameter real Agamma = 0.0 from [0.0 : inf]  `attr(info="area related body effect mismatch parameter" unit="sqrt(V)*m");
// Diode parameters
 parameter real N=1.0 from [1e-6:inf] `attr(info="emission coefficient");
 parameter real Is=1e-14 from [1e-20:inf] `attr(info="saturation current" unit="A" );
 parameter real Bv=100 from [1e-6:inf] `attr(info="reverse breakdown voltage" unit="V");
 parameter real Ibv=1e-3 from [1e-6:inf] `attr(info="current at reverse breakdown voltage" unit="A");
 parameter real Vj=1.0 from [1e-6:inf] `attr(info="junction potential" unit="V");
 parameter real Cj0=300e-15 from [0:inf] `attr(info="zero-bias junction capacitance" unit="F");
 parameter real M=0.5 from [1e-6:inf] `attr(info="grading coefficient");
 parameter real Area=1.0 from [1e-3:inf] `attr(info="diode relative area");
 parameter real Fc=0.5 from [1e-6:inf] `attr(info="forward-bias depletion capcitance coefficient");
 parameter real Tt=0.1e-9 from [1e-20:inf] `attr(info="transit time" unit="s" );
 parameter real Xti=3.0 from [1e-6:inf] `attr(info="saturation current temperature exponent");
// Temperature parameters
 parameter real Tnom = 26.85      `attr(info="parameter measurement temperature" unit = "Celsius");
// Local variables
real epsilonsi, epsilonox, Tnomk, T2, Tratio, Vto_T, Ucrit_T, Egnom, Eg, Phi_T;
real Weff, Leff, RDeff, RSeff, con1, con2, Vtoa, Kpa,Kpa_T,Gammaa, C_epsilon, xi;
real nnn, deltaV_RSCE, Vg, Vs, Vd, Vgs, Vgd, Vds, Vdso2, VG, VS, VD;
real VGprime, VP0, VSprime, VDprime, Gamma0, Gammaprime, Vp;
real n, X1, iff, X2, ir, Vc, Vdss, Vdssprime, deltaV, Vip;
real Lc, DeltaL, Lprime, Lmin, Leq, X3, irprime, Beta0, eta;
real Qb0, Beta0prime, nq, Xf, Xr, qD, qS, qI, qB, Beta, Ispecific, Ids, Vib, Idb, Ibb_T;
real A, B, Vt_T2, Eg_T1, Eg_T2, Vj_T2, Cj0_T2, F1, F2, F3, Is_T2;
real Id1, Id2, Id3, Id4, Is1, Is2, Is3, Is4, V1, V2, Ib_d, Ib_s, Qd, Qs, Qd1, Qd2, Qs1, Qs2;
real qb, qg, qgso, qgdo, qgbo, fourkt, Sthermal, gm, Sflicker, StoDswap, p_n_MOS;
//
analog begin
// Equation initialization
p_n_MOS = -1.0; // pMOS
A=7.02e-4;
B=1108.0;
epsilonsi = 1.0359e-10;     // Eqn 4
epsilonox = 3.453143e-11;   // Eqn 5
Tnomk = Tnom+273.15;              // Eqn 6
T2=$temperature;
Tratio = T2/Tnomk;
Vto_T = -Vto+Tcv*(T2-Tnomk); // Signs of Vto and Tcv changed for pMOS
Egnom = 1.16-0.000702*Tnomk*Tnomk/(Tnomk+1108);
Eg =    1.16-0.000702*T2*T2/(T2+1108);
Phi_T = Phi*Tratio - 3.0*$vt*ln(Tratio)-Egnom*Tratio+Eg;
Ibb_T = Ibb*(1.0+Ibbt*(T2 -Tnomk));
Weff = W + Dw;   // Eqn 25
Leff = L + Dl;   // Eqn 26
RDeff = ( (Hdif*Rsh)/Weff)/Np + Rdc;
RSeff = ( (Hdif*Rsh)/Weff)/Np + Rsc;
con1 = sqrt(Np*Weff*Ns*Leff);
Vt_T2=`P_K*T2/`P_Q;
Eg_T1=Eg-A*Tnomk*Tnomk/(B+Tnomk);
Eg_T2=Eg-A*T2*T2/(B+T2);
Vj_T2=(T2/Tnomk)*Vj-(2*Vt_T2)*ln(pow((T2/Tnomk),1.5))-((T2/Tnomk)*Eg_T1-Eg_T2);
Cj0_T2=Cj0*(1+M*(400e-6*(T2-Tnomk)-(Vj_T2-Vj)/Vj));
F1=(Vj/(1-M))*(1-pow((1-Fc),(1-M)));
F2=pow((1-Fc), (1+M));
F3=1-Fc*(1+M);
Is_T2=Is*pow( (T2/Tnomk), (Xti/N))*limexp((-Eg_T1/Vt_T2)*(1-T2/Tnomk));
con2 = (Cox*Ns*Np*Weff*Leff);
fourkt = 4.0*`P_K*T2;
//
if (LEVEL == 2)
 begin
  Ucrit_T = Ucrit*pow(Tratio, Ucex);
  Vtoa = Vto+Avto/con1;              // Eqn 27
  Kpa = Kp*(1.0+Akp/con1);           // Eqn 28
  Kpa_T = Kpa*pow( Tratio, Bex);     // Eqn 18
  Gammaa = Gamma+Agamma/con1;        // Eqn 29
  C_epsilon = 4.0*pow(22e-3, 2);     // Eqn 30
  xi = 0.028*(10.0*(Leff/Lk)-1.0);   // Eqn 31
  nnn = 1.0+0.5*(xi+ sqrt(pow(xi,2) + C_epsilon));
  deltaV_RSCE = (2.0*Q0/Cox)*(1.0/pow(nnn,2)); // Eqn 32
 end
//
// Model branch and node voltages
//

Vg = p_n_MOS*V(Gate, Bulk); 
Vs = p_n_MOS*V(Source, Bulk);
Vd = p_n_MOS*V(Drain, Bulk);
VG=Vg;        // Eqn 22
if ( (Vd-Vs) >= 0.0)
	begin
          StoDswap = 1.0;
	  VS=Vs;   // Eqn 23
          VD=Vd;   // Eqn 24
	end
else
	begin
          StoDswap = -1.0;
	  VD=Vs;
	  VS=Vd;
	end
if (LEVEL == 2)
    VGprime=VG-Vto_T-deltaV_RSCE+Phi_T+Gamma*sqrt(Phi_T);  // Eqn 33  nMOS equation
else
    VGprime=Vg-Vto_T+Phi_T+Gamma*sqrt(Phi_T);

if (LEVEL == 2)
 begin
  if (VGprime > 0)
	VP0=VGprime-Phi_T-Gammaa*(sqrt(VGprime+(Gammaa/2.0)*(Gammaa/2.0))-(Gammaa/2.0));  // Eqn 34
  else
	VP0 = -Phi_T;
  VSprime=0.5*(VS+Phi_T+sqrt(pow( (VS+Phi_T),2) + pow( (4.0*$vt),2)));  // Eqn 35
  VDprime=0.5*(VD+Phi_T+sqrt(pow( (VD+Phi_T),2) + pow( (4.0*$vt),2)));  // Eqn 35
  Gamma0=Gammaa-(epsilonsi/Cox)*((Leta/Leff)*(sqrt(VSprime)+sqrt(VDprime))-(3.0*Weta/Weff)*sqrt(VP0+Phi_T));  // Eqn 36
  Gammaprime = 0.5*(Gamma0+sqrt( pow(Gamma0,2) +0.1*$vt ));  // Eqn 37 
  if (VGprime > 0.0 )
           Vp = VGprime-Phi_T-Gammaprime*(sqrt(VGprime+(Gammaprime/2.0)*(Gammaprime/2.0)) - (Gammaprime/2.0)); // Eqn 38
  else
        Vp = -Phi_T;
  n = 1.0 +Gammaa/(2.0*sqrt(Vp+Phi_T+4.0*$vt));  // Eqn 39
 end
else
 begin
  if (VGprime > 0)
	Vp=VGprime-Phi_T-Gamma*(sqrt(VGprime+(Gamma/2.0)*(Gamma/2.0))-(Gamma/2.0));  // Eqn 34
  else
	Vp = -Phi_T;
  n = 1.0 +Gamma/(2.0*sqrt(Vp+Phi_T+4.0*$vt));  // Eqn 39
end
//
X1 = (Vp-VS)/$vt;
iff = ln(1.0+limexp(X1/2.0))*ln(1.0+limexp(X1/2.0));   // Eqn 44
X2 = (Vp-VD)/$vt;
ir = ln(1.0+limexp(X2/2.0))*ln(1.0+limexp(X2/2.0));    // Eqn 57
//
if (LEVEL == 2)
 begin
  Vc = Ucrit_T*Ns*Leff;  // Eqn 45
  Vdss = Vc*(sqrt( 0.25 + (($vt/(Vc))*sqrt(iff)))-0.5);  // Eqn 46;
  Vdssprime = Vc*(sqrt( 0.25 + ($vt/Vc)*(sqrt(iff)-0.75*ln(iff))) - 0.5) +$vt*(ln(Vc/(2.0*$vt)) - 0.6 ); // Eqn 47
  if (Lambda*(sqrt(iff) > (Vdss/$vt) ) )
          deltaV = 4.0*$vt*sqrt(Lambda*(sqrt(iff) -(Vdss/$vt)) + (1.0/64.0) );  // Eqn 48
  else    deltaV = 1.0/64.0;
  Vdso2 = (VD-VS)/2.0;        // Eqn 49
  Vip = sqrt( pow(Vdss, 2) + pow( deltaV,2)) - sqrt( pow( (Vdso2 - Vdss), 2) + pow (deltaV, 2));  // Eqn 50
  Lc = sqrt( (epsilonsi/Cox)*Xj);  // Eqn 51
  DeltaL = Lambda*Lc*ln(1.0+((Vdso2-Vip)/(Lc*Ucrit_T)));  // Eqn 52
  Lprime = Ns*Leff - DeltaL + ( (Vdso2+Vip)/Ucrit_T); // Eqn 53
  Lmin = Ns*Leff/10.0;  // Eqn 54
  Leq = 0.5*(Lprime + sqrt( pow(Lprime, 2) + pow(Lmin, 2)));   // Eqn 55
  X3 = (Vp-Vdso2-VS-sqrt( pow(Vdssprime, 2) + pow( deltaV, 2)) + sqrt( pow( (Vdso2-Vdssprime), 2) + pow(deltaV,2)))/$vt;
  irprime = ln(1.0+limexp(X3/2.0))*ln(1.0+limexp(X3/2.0));  // Eqn 56
  Beta0 = Kpa_T*(Np*Weff/Leq);     // Eqn 58
  eta = 0.3333333;  // Eqn 59 - pMOS
  Qb0 = Gammaa*sqrt(Phi_T);  // Eqn 60;
  Beta0prime = Beta0*(1.0 +(Cox/(EO*epsilonsi))*Qb0);  // Eqn 61
  nq = 1.0 +Gammaa/(2.0*sqrt(Vp+Phi_T+1e-6));          // Eqn 69
 end
else
  nq = 1.0 +Gamma/(2.0*sqrt(Vp+Phi_T+1e-6));          // Eqn 69
//
Xf = sqrt(0.25+iff);    // Eqn 70
Xr = sqrt(0.25+ir);     // Eqn 71
qD = -nq*( (4.0/15.0)*((3.0*pow( Xr,3) + 6.0*pow( Xr, 2)*Xf + 4.0*Xr*pow( Xf, 2) + 2.0*pow(Xf, 3))/(pow( (Xf+Xr), 2) ) ) -0.5);  // Eqn 72
qS = -nq*( (4.0/15.0)*((3.0*pow( Xf,3) + 6.0*pow( Xf, 2)*Xr + 4.0*Xf*pow( Xr, 2) + 2.0*pow(Xr, 3))/(pow( (Xf+Xr), 2) ) ) -0.5);  // Eqn 73
qI = -nq*( (4.0/3.0)*( (pow(Xf,2)+(Xf*Xr)+pow(Xr,2))/(Xf+Xr)) - 1.0);    // Eqn 74
if (LEVEL == 2)
  if (VGprime > 0)
  	qB = (-Gammaa*sqrt(Vp+Phi_T+1e-6))*(1.0/$vt) - ( (nq-1.0)/nq)*qI;  // Eqn 75
  else
	qB = -VGprime/$vt;
else 
    if (VGprime > 0)
  	qB = (-Gamma*sqrt(Vp+Phi_T+1e-6))*(1.0/$vt) - ( (nq-1.0)/nq)*qI;  // Eqn 75
  else
	qB = -VGprime/$vt;
//
if (LEVEL == 2)
  Beta = Beta0prime/(1.0 + (Cox/ (EO*epsilonsi))*$vt*abs(qB+eta*qI));      // Eqn 62
else
  Beta = Kp*(Weff/Leff)/(1+Theta*Vp);
//
Ispecific = 2.0*n*Beta*pow( $vt, 2);    // Eqn 65
//
if (LEVEL == 2)
  begin
    Ids = Ispecific*(iff-irprime);          // Eqn 66
    Vib = VD-VS-Ibn*2.0*Vdss;               // Eqn 67
    if ( Vib > 0.0)
         Idb = Ids*(Iba/Ibb_T)*Vib*exp( (-Ibb_T*Lc)/Vib);   // Eqn 68
    else
         Idb = 0.0;
  end
else
   Ids = Ispecific*(iff-ir);          // Eqn 66
//
Sthermal = fourkt*Beta*abs(qI);
gm = Beta*$vt*(sqrt( (4.0*iff/Ispecific) +1.0) - sqrt( (4.0*ir/Ispecific) + 1.0) );
Sflicker = (Kf*gm*gm)/(Np*Weff*Ns*Leff*Cox);
//
qb = con2*$vt*qB;
qg = con2*$vt*(-qI-qB);
qgso = Cgso*Weff*Np*(VG-VS);
qgdo = Cgdo*Weff*Np*(VG-VD);
qgbo = Cgbo*Leff*Np*VG;
// Drain and source diodes
if (StoDswap > 0.0)
     begin
        V1=p_n_MOS*V(Bulk, Drain_int);
        V2=p_n_MOS*V(Bulk, Source_int);
     end
else
     begin
        V2=p_n_MOS*V(Bulk, Drain_int);
        V1=p_n_MOS*V(Bulk, Source_int);
     end
Id1= (V1>-5.0*N*$vt) ? Area*Is_T2*(limexp( V1/(N*Vt_T2) )-1.0) : 0;
Qd1=(V1<Fc*Vj)? Tt*Id1+Area*(Cj0_T2*Vj_T2/(1-M))*(1-pow((1-V1/Vj_T2),(1-M))):0;
Id2=(V1<=-5.0*N*$vt) ? -Area*Is_T2 : 0;
Qd2=(V1>=Fc*Vj)? Tt*Id1+Area*Cj0_T2*(F1+(1/F2)*(F3*(V1-Fc*Vj_T2)+(M/(2.0*Vj_T2))*(V1*V1-Fc*Fc*Vj_T2*Vj_T2))):0;
Id3=(V1 == -Bv) ? -Ibv  : 0 ;
Id4=(V1<-Bv) ?-Area*Is_T2*(limexp(-(Bv+V1)/Vt_T2)-1.0+Bv/Vt_T2) : 0;
Ib_d = Id1+Id2+Id3+Id4;
Qd = Qd1+Qd2;
//
Is1= (V2>-5.0*N*$vt) ? Area*Is_T2*(limexp( V2/(N*Vt_T2) )-1.0) : 0;
Qs1=(V2<Fc*Vj)? Tt*Is1+Area*(Cj0_T2*Vj_T2/(1-M))*(1-pow((1-V2/Vj_T2),(1-M))):0;
Is2=(V2<=-5.0*N*$vt) ? -Area*Is_T2 : 0;
Qs2=(V2>=Fc*Vj)? Tt*Is1+Area*Cj0_T2*(F1+(1/F2)*(F3*(V2-Fc*Vj_T2)+(M/(2.0*Vj_T2))*(V2*V2-Fc*Fc*Vj_T2*Vj_T2))):0;
Is3=(V2 == -Bv) ? -Ibv  : 0 ;
Is4=(V2<-Bv) ?-Area*Is_T2*(limexp(-(Bv+V2)/Vt_T2)-1.0+Bv/Vt_T2) : 0;
Ib_s = Is1+Is2+Is3+Is4;
Qs = Qs1+Qs2;
// Current contributions
if ( StoDswap > 0.0)
 begin
     if (RDeff > 0.0)
	I(Drain, Drain_int) <+ V(Drain, Drain_int)/RDeff;
     else
	I(Drain, Drain_int) <+ V(Drain, Drain_int)/1e-7;
     if (RSeff > 0.0)
	I(Source, Source_int) <+ V(Source, Source_int)/RSeff;
     else
	I(Source, Source_int) <+ V(Source, Source_int)/1e-7;
   I(Drain_int, Source_int) <+ p_n_MOS*Ids;
   if (LEVEL == 2)
     I(Drain_int, Bulk) <+ p_n_MOS*Idb;
   I(Gate, Drain_int) <+ p_n_MOS*0.5*ddt(qg);
   I(Gate, Source_int) <+ p_n_MOS*0.5*ddt(qg);
   I(Drain_int, Bulk) <+ p_n_MOS*0.5*ddt(qb);
   I(Source_int, Bulk) <+ p_n_MOS*0.5*ddt(qb);
   I(Gate, Source_int) <+ p_n_MOS*ddt(qgso);
   I(Gate, Drain_int)  <+ p_n_MOS*ddt(qgdo);
   I(Gate, Bulk)   <+ p_n_MOS*ddt(qgbo);
   I(Bulk, Drain_int) <+ p_n_MOS*Ib_d;
   I(Bulk, Drain_int) <+ p_n_MOS*ddt(Qd);
   I(Bulk, Source_int) <+ p_n_MOS*Ib_s;
   I(Bulk, Source_int) <+ p_n_MOS*ddt(Qs);
   I(Drain_int, Source_int) <+ white_noise(Sthermal,"thermal");
   I(Drain_int, Source_int) <+ flicker_noise(Sflicker, Af, "flicker");
   I(Drain, Drain_int) <+ white_noise(fourkt/RDeff, "thermal");
   I(Source, Source_int) <+ white_noise(fourkt/RSeff, "thermal");
end
else
 begin
     if (RSeff > 0.0)
	I(Drain, Drain_int) <+ V(Drain, Drain_int)/RSeff;
     else
	I(Drain, Drain_int) <+ V(Drain, Drain_int)/1e-7;
     if (RDeff > 0.0)
	I(Source, Source_int) <+ V(Source, Source_int)/RDeff;
     else
	I(Source, Source_int) <+ V(Source, Source_int)/1e-7;
   I( Source_int, Drain_int) <+ p_n_MOS*Ids;
   if (LEVEL == 2)
       I(Source_int, Bulk) <+ p_n_MOS*Idb;
   I( Gate, Source_int) <+ p_n_MOS*0.5*ddt(qg);
   I( Gate, Drain_int) <+ p_n_MOS*0.5*ddt(qg);
   I( Source_int, Bulk) <+ p_n_MOS*0.5*ddt(qb);
   I( Drain_int, Bulk) <+ p_n_MOS*0.5*ddt(qb);
   I( Gate, Drain_int) <+ p_n_MOS*ddt(qgso);
   I( Gate, Source_int)  <+ p_n_MOS*ddt(qgdo);
   I( Gate, Bulk)   <+ p_n_MOS*ddt(qgbo);
   I( Bulk, Source_int) <+ p_n_MOS*Ib_d;
   I( Bulk, Source_int) <+ p_n_MOS*ddt(Qd);
   I( Bulk, Drain_int) <+ p_n_MOS*Ib_s;
   I( Bulk, Drain_int) <+ p_n_MOS*ddt(Qs);
   I( Source_int, Drain_int) <+ white_noise(Sthermal,"thermal");
   I( Source_int, Drain_int) <+ flicker_noise(Sflicker, Af, "flicker");
   I( Source_int, Source) <+ white_noise(fourkt/RDeff, "thermal");
   I( Drain_int, Drain) <+ white_noise(fourkt/RSeff, "thermal");
 end
end
endmodule
