%
% This document contains the chapter about harmonic balance analysis.
%
% Copyright (C) 2005 Stefan Jahn <stefan@lkcc.org>
% Copyright (C) 2005 Michael Margraf <Michael.Margraf@alumni.TU-Berlin.DE>
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.1
% or any later version published by the Free Software Foundation.
%

\chapter{Harmonic Balance Analysis}
\label{sec:hb_analysis}

Harmonic balance is a non-linear, frequency-domain, steady-state
simulation.  The voltage and current sources create discrete
frequencies resulting in a spectrum of discrete frequencies at every
node in the circuit. Linear circuit components are solely modeled in
frequency domain. Non-linear components are modeled in time domain and
Fourier-transformed before each solving step.  The informations in
this chapter are taken from \cite{Maas1} (chapter 3) which is a very
nice and well-written publication on this topic.

\addvspace{12pt}

The harmonic balance simulation is ideal for situations where
transient simulation methods are problematic. These are:
\begin{itemize}
\item components modeled in frequency domain, for instance (dispersive)
      transmission lines
\item circuit time constants large compared to period of simulation
      frequency
\item circuits with lots of reactive components
\end{itemize}
Harmonic balance methods, therefore, are the best choice for most microwave
circuits excited with sinusoidal signals (e.g. mixers, power amplifiers).


\section{The Basic Concept}

As non-linear elements can only be modeled in time domain, the circuit
first must be separated into a linear and a non-linear part. The
internal impedances $Z_i$ of the voltage sources are put into the
linear part as well. Figure \ref{fig:hb_concept} illustrates the
concept. Let us define the following symbols:
\begin{description}
\item[] M = number of (independent) voltage sources
\item[] N = number of connections between linear and non-linear subcircuit
\item[] K = number of calculated harmonics
\end{description}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=9cm]{hb_concept}
\end{center}
\caption{circuit partitioning in harmonic balance}
\label{fig:hb_concept}
\end{figure}
\FloatBarrier

The linear circuit is modeled by two transadmittance matrices:
The first one $(\tilde{\underline{Y}})$
relates the source voltages $v_{S,1}...v_{S,M}$ to the interconnection
currents $i_1...i_N$ and the second one $(\hat{\underline{Y}})$
relates the interconnection
voltages $v_1...v_N$ to the interconnection currents $i_1...i_N$.
Taking both, we can express the current flowing through the
interconnections between linear and non-linear subcircuit:

\begin{equation}
\label{eqn:HBlin}
(\underline{I})
  = (\underline{\tilde{Y}})\cdot (\underline{V}_S) + (\underline{\hat{Y}})\cdot (\underline{V})
  = (\underline{I}_S) + (\underline{\hat{Y}})\cdot (\underline{V})
\end{equation}
Because $(\underline{V}_S)$ is known and constant, the first term
can already be computed to give $(\underline{I}_S)$.

\addvspace{12pt}

The non-linear circuit is modeled by its current function
$i(t) = f_g(v_1, ..., v_N)$
and by the charge of its capacitances
$q(t) = f_q(v_1, ..., v_N)$.
These functions must be Fourier-transformed to give the
frequency-domain vectors $(\underline{Q})$ and $(\underline{I}_G)$,
respectively.

\addvspace{12pt}

A simulation result is found if the currents through the
interconnections are the same for the linear and the non-linear
subcircuit. This principle actually gave the harmonic balance
simulation its name, because through the interconnections the
currents of the linear and non-linear subcircuits have to be
\textit{balanced} at every \textit{harmonic} frequency. (To
be precise the described method is called KCL-HB, Kirchhoff's
current law harmonic balance.) So, the non-linear equation
system that needs to be solved writes:
\begin{equation}
(\underline{0})
  = \underbrace{(\underline{I}_S) + (\underline{\hat{Y}})\cdot (\underline{V})}_{\text{linear}}
  + \underbrace{j\cdot (\underline{\Omega})\cdot (\underline{Q}) + (\underline{I}_G)}_{\text{non-linear}}
\end{equation}
where matrix $(\underline{\Omega})$ contains the angular frequencies
on the first main diagonal and zeros anywhere else, $(\underline{0})$
is zero matrix.

\addvspace{12pt}

After each iteration step, the inverse Fourier transformation must
be applied to the voltage vector $(\underline{V})$. Then the time domain
voltages $v_1...v_N$ are put into $i(t) = f_g(v_1, ..., v_N)$
and $q(t) = f_q(v_1, ..., v_N)$ again. Now, a Fourier transformation
gives the vectors $(\underline{Q})$ and $(\underline{I}_G)$ for the
next iteration step. After repeating this several times, a simulation
result has hopefully be found.

\section{Going through each Step}

\subsection{Creating Transadmittance Matrix}

It needs several steps to get the transadmittance matrices $[\tilde{Y}]$
and $[\hat{Y}]$ mentioned in equation \eqref{eqn:HBlin}. First the MNA
matrix of the linear subcircuit (figure \ref{fig:hb_concept}) is created
(chapter \ref{sec:MNA}). Then the transimpedance matrix is derived by
exciting one by one the port nodes of the MNA matrix with unity current.
After that the transadmittance matrix is calculated by inverting the
transimpedance matrix. Finally the matrices $[\tilde{Y}]$ and $[\hat{Y}]$
are filled with the corresponding elements of the overall transadmittance
matrix.

\addvspace{12pt}

Now this should be described in more detail: By use of the MNA matrix
$[A]$, the $n$-th column of the transimpedance matrix $[Z]$ should be
calculated. The voltage source at port $n$ is connected to node $i$
(positive terminal) and to port $j$ (negative terminal). This results
in the following equation:
\begin{equation}
\label{eqn:HBtrans}
[A]\cdot
\begin{bmatrix}
V_1\\
\vdots\\
V_K\\
\end{bmatrix}
=
\begin{bmatrix}
0\\
\vdots\\
1\\
\vdots\\
-1\\
\vdots\\
0\\
\end{bmatrix}
\begin{matrix}
 \\
 \\
\leftarrow i\text{-th row}\\
 \\
\leftarrow j\text{-th row}\\
 \\
 \\
\end{matrix}
\end{equation}
After having solved it, $Z_{1,n}$...$Z_{N+M,n}$ are obtained
simply by subtraction of the node voltages:
\begin{equation}
Z_{m,n} = V_k - V_l
\end{equation}
Here the voltage source at port $m$ is connected to node $k$
(positive terminal) and to node $l$ (negative terminal).

\addvspace{12pt}

The next column of $[Z]$ is obtained by changing the right-hand
side of equation \eqref{eqn:HBtrans} appropriately. As this has to
be done $N+M$ times, it is strongly recommended to use LU
decomposition.

\addvspace{12pt}

One further thing must be mentioned: Because the non-linear
components are missing in the linear MNA matrix, there are often
components that are completely disconnected from the rest of the
circuit. The resulting MNA matrix cannot be solved. To avoid
this problem, shunt each port with a $100\Omega$ resistor. The
effect of these resistors can be easily removed by subtracting
0.01S from the first main diagonal of the transadmittance matrix.


\subsection{Termination Criteria}

Frequency components with very different magnitude appear in harmonic
balance simulation. In order to detect when the solver has found an
accurate solution, an absolute as well as relative criteria must be
used on all nodes and at all frequencies. The analysis is regarded as
finished if one of the criteria is satisfied.

\addvspace{12pt}

The absolute and relative criteria write as follows:
\begin{equation}
\left| \tilde{I}_{n,k} + \hat{I}_{n,k} \right| < \epsilon_{abs}
  \qquad \text{for all} \quad n, k
\end{equation}
\begin{equation}
2\cdot \left| \frac{\tilde{I}_{n,k} + \hat{I}_{n,k}}
                   {\tilde{I}_{n,k} - \hat{I}_{n,k}} \right|
  < \epsilon_{rel}  \qquad \text{for all} \quad n, k
\end{equation}
where $\tilde{I}_{n,k}$ is the current of the linear circuit
partition for node $n$ and frequency $k$ and $\hat{I}_{n,k}$
is the current of the non-linear circuit partition.


\subsection{Frequency-Time Domain Transformation}

During every iteration step, the time domain values have to be transformed
into frequency domain and afterwards back again. A standard Fourier
Transformation is not
useful, because with multi-tone excitation many mixing products appear.
The best way to cope with this problem is to use multi-dimensional
Fast-Fourier-Transformation (FFT). The information in this subsection
stems from \cite{Press}, where the theoretical background is explained,
too.

\addvspace{12pt}

First, the one-dimensional FFT will be discused. The FFT is a strongly
optimized discrete Fourier Transformation (DFT). It takes advantage of
the symmetry and periodicity of the trigonometric functions in order
to avoid redundancy. To achieve this, the number of data samples must
be a power of two (2, 4, 8, 16, 32, ...). As first step, the data array
is reordered by the bit-reversal method. Finally, the frequency domain
values are calculated with the Danielson-Lanzcos algorithm. The
following source code was taken from \cite{Press} and contains only a
few changes. (The function \texttt{SWAP(X, Y)} exchanges the values in
\texttt{X} and \texttt{Y}.)

\addvspace{12pt}

Parameters:\\
\begin{tabular}{lcl}
\texttt{num}    & - & number of complex samples\\
\texttt{data[]} & - & array containing the data samples,\\
                &   & real and imaginary part in alternating order (length: 2*\texttt{num})\\
\texttt{isign}  & - & is 1 to calculate FFT and -1 to calculate inverse FFT
\end{tabular}

\addvspace{12pt}


\texttt{>\quad // bit reversal method} \\
\texttt{>\quad int i, j, m, n;} \\
\texttt{>\quad n = 2*num;} \\
\texttt{>\quad j = 0;} \\
\texttt{>\quad for (i=0; i<n; i+=2) \{} \\
\texttt{>\quad \qquad if(j > i) \{   // was index already swapped ?} \\
\texttt{>\quad \qquad\qquad SWAP(data[j], data[i]);   // swap real part} \\
\texttt{>\quad \qquad\qquad SWAP(data[j+1], data[i+1]);   // swap imaginary part} \\
\texttt{>\quad \qquad \}} \\
\texttt{>\quad \qquad m = n/2;} \\
\texttt{>\quad \qquad while (m >= 2 \&\& j >= m) \{  // calculate next swap index} \\
\texttt{>\quad \qquad\qquad j -= m;} \\
\texttt{>\quad \qquad\qquad m >>= 1;} \\
\texttt{>\quad \qquad \}} \\
\texttt{>\quad \qquad j += m;} \\
\texttt{>\quad \}} \\
\texttt{>\quad } \\
\texttt{>\quad // Danielson-Lanzcos algorithm} \\
\texttt{>\quad int mmax, istep;} \\
\texttt{>\quad double wtemp, theta, wr, wi, wpr, wpi, tempi, tempr;} \\
\texttt{>\quad mmax = 2;} \\
\texttt{>\quad while (n > mmax) \{} \\
\texttt{>\quad \qquad istep = mmax << 1;} \\
\texttt{>\quad \qquad theta = isign * (2*pi/mmax);} \\
\texttt{>\quad \qquad wtemp = sin(0.5*theta);} \\
\texttt{>\quad \qquad wpr = -2.0*wtemp*wtemp;} \\
\texttt{>\quad \qquad wpi = sin(theta);} \\
\texttt{>\quad \qquad wr = 1.0;} \\
\texttt{>\quad \qquad wi = 0.0;} \\
\texttt{>\quad \qquad for (m=1; m<mmax; m+=2) \{} \\
\texttt{>\quad \qquad\qquad for (i=m; i<=n; i+=istep) \{} \\
\texttt{>\quad \qquad\qquad\qquad j = i+mmax;} \\
\texttt{>\quad \qquad\qquad\qquad tempr = wr*data[j-1] - wi*data[j];} \\
\texttt{>\quad \qquad\qquad\qquad tempi = wr*data[j] + wi*data[j-1];} \\
\texttt{>\quad \qquad\qquad\qquad data[j-1] = data[i-1] - tempr;} \\
\texttt{>\quad \qquad\qquad\qquad data[j] = data[i] - tempi;} \\
\texttt{>\quad \qquad\qquad\qquad data[i-1] += tempr;} \\
\texttt{>\quad \qquad\qquad\qquad data[i] += tempi;} \\
\texttt{>\quad \qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad wr = (wtemp=wr)*wpr - wi*wpi + wr;} \\
\texttt{>\quad \qquad\qquad wi = wi*wpr + wtemp*wpi + wi;} \\
\texttt{>\quad \qquad \}} \\
\texttt{>\quad \qquad mmax = istep;} \\
\texttt{>\quad \}} \\

\addvspace{12pt}

There are many other FFT algorithms mainly aiming at higher speed.
Two that are worth mentioning are base-4 FFT (about 20\% faster)
and the Winograd Fourier transform algorithm (up to 100\% faster).
However, the algorithms are much more complex.

\addvspace{12pt}

Fourier Transformations in more than one dimension soon become
very time consuming. Using FFT mechanisms is therefore mandatory.
A more-dimensional Fourier Transformation consists of many
one-dimensional Fourier Transformations (1D-FFT). First, 1D-FFTs
are performed for the data of the first dimension at every index
of the second dimension. The results are used as input data for
the second dimension that is performed the same way with respect
to the third dimension. This procedure is continued until all
dimensions are calculated. The following routine computes the
$n$-dimensional FFT and was taken from \cite{Press}.

\addvspace{12pt}

Parameters:\\
\begin{tabular}{lcl}
\texttt{ndim}   & - & number of dimensions\\
\texttt{num[]}  & - & array containing the number of complex samples for every dimension\\
\texttt{data[]} & - & array containing the data samples,\\
                &   & real and imaginary part in alternating order (length: 2*sum of \texttt{num[]}),\\
                &   & going through the array, the first dimension changes least rapidly !\\
                &   & all subscripts range from 1 to maximum value !\\
\texttt{isign}  & - & is 1 to calculate FFT and -1 to calculate inverse FFT
\end{tabular}

\addvspace{12pt}

\texttt{>\quad int idim, i1, i2, i3, i2rev, i3rev, ip1, ip2, ip3, ifp1, ifp2;} \\
\texttt{>\quad int ibit, k1, k2, n, nprev, nrem, ntot;} \\
\texttt{>\quad double tempi, tempr, wtemp, theta, wr, wi, wpi, wpr;} \\
\texttt{>\quad } \\
\texttt{>\quad ntot = 1;} \\
\texttt{>\quad for (idim=1; idim<=ndim; idim++) // compute total number of complex values} \\
\texttt{>\quad \qquad ntot *= num[idim];} \\
\texttt{>\quad } \\
\texttt{>\quad nprev = 1;} \\
\texttt{>\quad for (idim=ndim; idim>=1; idim--) \{ // main loop over the dimensions} \\
\texttt{>\quad \qquad n = num[idim];} \\
\texttt{>\quad \qquad nrem = ntot/(n*nprev);} \\
\texttt{>\quad \qquad ip1 = nprev << 1;} \\
\texttt{>\quad \qquad ip2 = ip1*n;} \\
\texttt{>\quad \qquad ip3 = ip2*nrem;} \\
\texttt{>\quad \qquad i2rev = 1;} \\
\texttt{>\quad } \\
\texttt{>\quad \qquad for (i2=1; i2<=ip2; i2+=ip1) \{ // bit-reversal method} \\
\texttt{>\quad \qquad\qquad if (i2 < i2rev) \{} \\
\texttt{>\quad \qquad\qquad\qquad for (i1=i2; i1<=i2+ip1-2; i1+=2) \{} \\
\texttt{>\quad \qquad\qquad\qquad\qquad for (i3=i1; i3<=ip3; i3+=ip2) \{} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad i3rev = i2rev+i3-i2;} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad SWAP(data[i3],data[i3rev]);} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad SWAP(data[i3+1],data[i3rev+1]);} \\
\texttt{>\quad \qquad\qquad\qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad ibit=ip2 >> 1;} \\
\texttt{>\quad \qquad\qquad while (ibit >= ip1 \&\& i2rev > ibit) \{} \\
\texttt{>\quad \qquad\qquad\qquad i2rev -= ibit;} \\
\texttt{>\quad \qquad\qquad\qquad ibit >>= 1;} \\
\texttt{>\quad \qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad i2rev += ibit;} \\
\texttt{>\quad \qquad \}} \\
\texttt{>\quad } \\
\texttt{>\quad \qquad ifp1 = ip1;} \\
\texttt{>\quad \qquad while (ifp1 < ip2) \{ // Danielson-Lanzcos algorithm} \\
\texttt{>\quad \qquad\qquad ifp2 = ifp1 << 1;} \\
\texttt{>\quad \qquad\qquad theta = isign*2*pi/(ifp2/ip1);} \\
\texttt{>\quad \qquad\qquad wtemp = sin(0.5*theta);} \\
\texttt{>\quad \qquad\qquad wpr = -2.0*wtemp*wtemp;} \\
\texttt{>\quad \qquad\qquad wpi = sin(theta);} \\
\texttt{>\quad \qquad\qquad wr = 1.0; wi = 0.0;} \\
\texttt{>\quad \qquad\qquad for (i3=1; i3<=ifp1; i3+=ip1) \{} \\
\texttt{>\quad \qquad\qquad\qquad for (i1=i3; i1<=i3+ip1-2; i1+=2) \{} \\
\texttt{>\quad \qquad\qquad\qquad\qquad for (i2=i1; i2<=ip3; i2+=ifp2) \{} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad k1 = i2;} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad k2 = k1+ifp1;} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad tempr = wr*data[k2] - wi*data[k2+1];} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad tempi = wr*data[k2+1] + wi*data[k2];} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad data[k2] = data[k1] - tempr;} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad data[k2+1] = data[k1+1] - tempi;} \\
\texttt{>\quad \qquad\qquad\qquad\qquad\qquad data[k1] += tempr; data[k1+1] += tempi;} \\
\texttt{>\quad \qquad\qquad\qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad\qquad wr = (wtemp=wr)*wpr-wi*wpi+wr;} \\
\texttt{>\quad \qquad\qquad\qquad wi = wi*wpr+wtemp*wpi+wi;} \\
\texttt{>\quad \qquad\qquad \}} \\
\texttt{>\quad \qquad\qquad ifp1 = ifp2;} \\
\texttt{>\quad \qquad \}} \\
\texttt{>\quad \qquad nprev *= n;} \\
\texttt{>\quad \}} \\

