%
% This document contains the chapter about harmonic balance analysis.
%
% Copyright (C) 2005 Stefan Jahn <stefan@lkcc.org>
% Copyright (C) 2005 Michael Margraf <Michael.Margraf@alumni.TU-Berlin.DE>
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.1
% or any later version published by the Free Software Foundation.
%

\chapter{Harmonic Balance Analysis}
\label{sec:hb_analysis}

Harmonic balance is a non-linear, frequency-domain, steady-state
simulation.  The voltage and current sources create discrete
frequencies resulting in a spectrum of discrete frequencies at every
node in the circuit. Linear circuit components are solely modeled in
frequency domain. Non-linear components are modeled in time domain and
Fourier-transformed before each solving step.  The informations in
this chapter are taken from \cite{Maas1} (chapter 3) which is a very
nice and well-written publication on this topic.

\addvspace{12pt}

The harmonic balance simulation is ideal for situations where
transient simulation methods are problematic. These are:
\begin{itemize}
\item components modeled in frequency domain, for instance (dispersive)
      transmission lines
\item circuit time constants large compared to period of simulation
      frequency
\item circuits with lots of reactive components
\end{itemize}
Harmonic balance methods, therefore, are the best choice for most microwave
circuits excited with sinusoidal signals (e.g. mixers, power amplifiers).


\section{The Basic Concept}

As non-linear elements can only be modeled in time domain, the circuit
first must be separated into a linear and a non-linear part. The
internal impedances $Z_i$ of the voltage sources are put into the
linear part as well. Figure \ref{fig:hb_concept} illustrates the
concept. Let us define the following symbols:
\begin{description}
\item[] M = number of (independent) voltage sources
\item[] N = number of connections between linear and non-linear subcircuit
\item[] K = number of calculated harmonics
\item[] L = number of nodes in linear subcircuit
\end{description}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=9cm]{hb_concept}
\end{center}
\caption{circuit partitioning in harmonic balance}
\label{fig:hb_concept}
\end{figure}
\FloatBarrier

The linear circuit is modeled by two transadmittance matrices:
The first one $\tilde{\boldsymbol{Y}}$
relates the source voltages $v_{S,1}...v_{S,M}$ to the interconnection
currents $i_1...i_N$ and the second one $\hat{\boldsymbol{Y}}$
relates the interconnection
voltages $v_1...v_N$ to the interconnection currents $i_1...i_N$.
Taking both, we can express the current flowing through the
interconnections between linear and non-linear subcircuit:

\begin{equation}
\label{eqn:HBlin}
\boldsymbol{I}
  = \boldsymbol{\tilde{Y}}_{N\times M}\cdot \boldsymbol{V}_S +
    \boldsymbol{\hat{Y}}_{N\times N}\cdot \boldsymbol{V}
  = \boldsymbol{I}_S + \boldsymbol{\hat{Y}}\cdot \boldsymbol{V}
\end{equation}
Because $\boldsymbol{V}_S$ is known and constant, the first term
can already be computed to give $\boldsymbol{I}_S$. Taking the
whole linear network as one block is called the "piecewise"
harmonic balance technique.

\addvspace{12pt}

The non-linear circuit is modeled by its current function
$i(t) = f_g(v_1, ..., v_P)$
and by the charge of its capacitances
$q(t) = f_q(v_1, ..., v_Q)$.
These functions must be Fourier-transformed to give the
frequency-domain vectors $\boldsymbol{Q}$ and $\boldsymbol{I}_G$,
respectively.

\addvspace{12pt}

A simulation result is found if the currents through the
interconnections are the same for the linear and the non-linear
subcircuit. This principle actually gave the harmonic balance
simulation its name, because through the interconnections the
currents of the linear and non-linear subcircuits have to be
\textit{balanced} at every \textit{harmonic} frequency. (To
be precise the described method is called KCL-HB, Kirchhoff's
current law harmonic balance.) So, the non-linear equation
system that needs to be solved writes:
\begin{equation}
\label{eqn:HBeqn}
\textbf{F}(\textbf{V})
  = \underbrace{(\boldsymbol{I}_S) + (\boldsymbol{\hat{Y}})\cdot (\boldsymbol{V})}_{\text{linear}}
  + \underbrace{j\cdot \boldsymbol{\Omega}\cdot \boldsymbol{Q} + \boldsymbol{I}_G}_{\text{non-linear}}
  = \boldsymbol{0}
\end{equation}
where matrix $\boldsymbol{\Omega}$ contains the angular frequencies
on the first main diagonal and zeros anywhere else, $\boldsymbol{0}$
is zero matrix.

\addvspace{12pt}

After each iteration step, the inverse Fourier transformation must
be applied to the voltage vector $\boldsymbol{V}$. Then the time domain
voltages $v_{0,1}...v_{K,N}$ are put into $i(t) = f_g(v_1, ..., v_P)$
and $q(t) = f_q(v_1, ..., v_Q)$ again. Now, a Fourier transformation
gives the vectors $\boldsymbol{Q}$ and $\boldsymbol{I}_G$ for the
next iteration step. After repeating this several times, a simulation
result has hopefully be found.

\addvspace{12pt}

Having found this result means having got the voltages $v_1...v_N$ at
the interconnections of the two subcircuits. With these values the
voltages at all nodes can be calculated: Forget about the non-linear
subcircuit, put voltage sources at the former interconnections (using
the calculated values) and perform a normal AC simulation. After that
the simulation is complete.

\section{Going through each Step}

\subsection{Creating Transadmittance Matrix}

It needs several steps to get the transadmittance matrices $[\tilde{Y}]$
and $[\hat{Y}]$ mentioned in equation \eqref{eqn:HBlin}. First the MNA
matrix of the linear subcircuit (figure \ref{fig:hb_concept}) is created
(chapter \ref{sec:MNA}) without the voltage sources $S_1$...$S_M$. Then
the transimpedance matrix is derived by
exciting one by one the port nodes of the MNA matrix with unity current.
After that the transadmittance matrix is calculated by inverting the
transimpedance matrix. Finally the matrices $[\tilde{Y}]$ and $[\hat{Y}]$
are filled with the corresponding elements of the overall transadmittance
matrix.

\addvspace{12pt}

Note: The MNA matrix of the linear subcircuit has $L$ nodes.
Every node, that is connected to the non-linear subcircuit or/and is
connected to a voltage source, is called "port" in the following text.
So, there are $M+N$ ports. The $N$ ports of the interconnections are
all with reference to ground, whereas the other $M$ ports can be
differential.

\addvspace{12pt}

Now this should be described in more detail: By use of the MNA matrix
$[A]$, the $n$-th column of the transimpedance matrix $[Z]$ should be
calculated. The voltage source at port $n$ is connected to node $i$
(positive terminal) and to node $j$ (negative terminal). This results
in the following equation. (If port $n$ is referenced to ground, the
-1 is simply omitted.)
\begin{equation}
\label{eqn:HBtrans}
[A]\cdot
\begin{bmatrix}
V_1\\
\vdots\\
V_L\\
\end{bmatrix}
=
\begin{bmatrix}
0\\
\vdots\\
1\\
\vdots\\
-1\\
\vdots\\
0\\
\end{bmatrix}
\begin{matrix}
 \\
 \\
\leftarrow i\text{-th row}\\
 \\
\leftarrow j\text{-th row}\\
 \\
 \\
\end{matrix}
\end{equation}
After having solved it, $Z_{1,n}$...$Z_{N+M,n}$ are obtained
simply by subtraction of the node voltages:
\begin{equation}
Z_{m,n} = V_k - V_l
\end{equation}
Here the voltage source at port $m$ is connected to node $k$
(positive terminal) and to node $l$ (negative terminal).

\addvspace{12pt}

The next column of $[Z]$ is obtained by changing the right-hand
side of equation \eqref{eqn:HBtrans} appropriately. As this has to
be done $N+M$ times, it is strongly recommended to use LU
decomposition.

\addvspace{12pt}

One further thing must be mentioned: Because the non-linear
components are missing in the linear MNA matrix, there are often
components that are completely disconnected from the rest of the
circuit. The resulting MNA matrix cannot be solved. To avoid
this problem, shunt each port with a $100\Omega$ resistor. The
effect of these resistors can be easily removed by subtracting
0.01S from the first main diagonal of the transadmittance matrix.


\subsection{Starting Values}

A difficult question is how to find appropriate start values for the
harmonic balance simulation. It is recommended to first perform a DC
analysis and start the algorithm with this result. In many situation
(perhaps always) an even better starting point can be achieved by
also using the result of a linear AC simulation. However with a large
signal strength and strong non-linearities, convergence may still
fail. Then, the following procedure might succeed: Perform HB
simulation by applying half of the desired signal levels. If convergence
is reached, the result can be used as start values for the simulation
with the full signal levels. Otherwise the amplitude of the signals can
be further decreased in order to repeat the above-mentioned procedure.


\subsection{Solution algorithm}

To perform a HB simulation, the multi-dimensional, non-linear function
\ref{eqn:HBeqn} has to be solved. One of the best possibilities to
do so is the Newton method:
\begin{equation}
\textbf{V}_{n+1} = \textbf{V}_n - \textbf{J}_F (\textbf{V}_n)^{-1}
                   \cdot \textbf{F} (\textbf{V}_n)
\end{equation}
with $\textbf{J}_F$ being the Jacobian matrix. DC and transient
simulation also use this technique, but here a problem appears:
The derivatives of the component models are not given in frequency
domain. Thus, the Jacobian must be calculated starting at the HB
equation \ref{eqn:HBeqn}:
\begin{equation}
\boldsymbol{J}_F (\boldsymbol{V}_n) = \frac{d\boldsymbol{F} (\boldsymbol{V})}{d\boldsymbol{V}}
    = \boldsymbol{\hat{Y}}_{N \times N} + \frac{\partial \boldsymbol{I}_G}{\partial \boldsymbol{V}}
     + j\cdot \boldsymbol{\Omega}\frac{\partial \boldsymbol{I}_G}{\partial \boldsymbol{V}}
    = \boldsymbol{\hat{Y}}_{N \times N} + \boldsymbol{J}_{F,G}
     + j\cdot \boldsymbol{\Omega}\cdot\boldsymbol{F}_{F,Q}
\end{equation}
So, two Jacobian matrices have to be built, one for the current
$\boldsymbol{I}_G$ and one for the charge $\boldsymbol{Q}$. Both resulted
from a Fourier Transformation. The two operations (Fourier Transformation
and differentiation) can be exchanged. Hence, the Jacobian matrices
are built in time domain and transformed into frequency domain afterwards.

\addvspace{12pt}

To obtain a practical algorithm of this procedure, the DFT is best written
as matrix equation. By having a look at equation \ref{eqn:DFT} and
\ref{eqn:IDFT}, it becomes clear how this works. The harmonic factors
$\exp(j\omega_k t_n)$ build the matrix $\boldsymbol{\Gamma}$:
\begin{align}
\text{DFT:}  \qquad & \boldsymbol{U}(j\omega) = \boldsymbol{\Gamma}\cdot \boldsymbol{u}(t) \\
\text{IDFT:} \qquad & \boldsymbol{u}(t) = \boldsymbol{\Gamma}^{-1}\cdot \boldsymbol{U}(j\omega)
\end{align}
with $\boldsymbol{u}$ and $\boldsymbol{U}$ being the vectors of the time
and frequency values, respectively. Now, it is possible to transform the
desired Jacobian matrix into frequency domain:
\begin{equation}
\boldsymbol{J}_{F,G} = \frac{\partial\boldsymbol{I}_G}{\partial\boldsymbol{V}}
  = \boldsymbol{\Gamma}\cdot\frac{\partial\boldsymbol{i}}{\partial\boldsymbol{v}}
    \cdot\boldsymbol{\Gamma}^{-1}
\end{equation}
This formula seems to be quite clear, but it has to be pointed out how
this works with FFT algorithm. With
$\boldsymbol{\Gamma}^{-1} = (\boldsymbol{\Gamma}^{-1})^T$
(see equation \ref{eqn:IDFT}) and
$(\boldsymbol{A}\cdot\boldsymbol{B})^T = \boldsymbol{B}^T\cdot \boldsymbol{A}^T$,
it follows:
\begin{equation}
\boldsymbol{J}_{F,G}
  = \boldsymbol{\Gamma}\cdot\frac{\partial\boldsymbol{i}}{\partial\boldsymbol{v}}
    \cdot\boldsymbol{\Gamma}^{-1}
  = \left( \boldsymbol{\Gamma}^{-1}\cdot \left( \boldsymbol{\Gamma} \cdot
    \frac{\partial\boldsymbol{i}}{\partial\boldsymbol{v}} \right)^T \right)^T
\end{equation}
So, there are two steps to perform an FFT-based transformation of the time
domain Jacobian matrix into the frequency domain Jacobian:
\begin{enumerate}
\item Perform an FFT on every column of the Jacobian and build a new matrix
      $\boldsymbol{A}$ with this result, i.e. the first column of
      $\boldsymbol{A}$ is the FFTed first column of the Jacobian and so on.
\item Perform an IFFT on every row of the matrix $\boldsymbol{A}$ and build
      a new matrix $\boldsymbol{B}$ with this result, i.e. the first row of
      $\boldsymbol{B}$ is the IFFTed first row of $\boldsymbol{A}$ and so on.
\end{enumerate}


\subsection{Termination Criteria}

Frequency components with very different magnitude appear in harmonic
balance simulation. In order to detect when the solver has found an
accurate solution, an absolute as well as relative criteria must be
used on all nodes and at all frequencies. The analysis is regarded as
finished if one of the criteria is satisfied.

\addvspace{12pt}

The absolute and relative criteria write as follows:
\begin{equation}
\left| \tilde{I}_{n,k} + \hat{I}_{n,k} \right| < \epsilon_{abs}
  \qquad \text{for all} \quad n, k
\end{equation}
\begin{equation}
2\cdot \left| \frac{\tilde{I}_{n,k} + \hat{I}_{n,k}}
                   {\tilde{I}_{n,k} - \hat{I}_{n,k}} \right|
  < \epsilon_{rel}  \qquad \text{for all} \quad n, k
\end{equation}
where $\tilde{I}_{n,k}$ is the current of the linear circuit
partition for node $n$ and frequency $k$ and $\hat{I}_{n,k}$
is the current of the non-linear circuit partition.


\subsection{Frequency-Time Domain Transformation}

During every iteration step of the harmonic balance, the time domain
values have to be transformed into frequency domain and afterwards
back again. This is done by the so-called Fourier Transformation and
the inverse Fourier Transformation, respectively:
\begin{eqnarray}
\text{Fourier Transformation:} & \qquad &
     \underline{U}(j\omega) =
     \int\limits_{-\infty}^{\infty} u(t)\cdot e^{-j\omega\cdot t} \; dt \\
\text{inverse Fourier Transformation:} & \qquad &
     u(t) = \frac{1}{2\pi} \cdot \int\limits_{-\infty}^{\infty}
            \underline{U}(j\omega)\cdot e^{j\omega\cdot t} \; d\omega
\end{eqnarray}
In digital systems the data $u(t)$ or $\underline{U}(j\omega)$,
respectively, consists of a finite number $N$ of samples $u_k$ and
$\underline{U}_n$. This leads to the discrete Fourier Transformation
(DFT) and its inverse operation (IDFT):
\begin{eqnarray}
\label{eqn:DFT}
\text{DFT:} & \qquad &
     \underline{U}_n =
     \sum_{k=0}^{N-1} u_k\cdot \exp\left( -j\cdot n\frac{2\pi\cdot k}{N} \right) \\
\label{eqn:IDFT}
\text{IDFT:} & \qquad &
     u_k = \frac{1}{N} \cdot \sum_{n=0}^{N}
            \underline{U}_n\cdot \exp\left( j\cdot k\frac{2\pi\cdot n}{N} \right)
\end{eqnarray}
The absolute time and frequency values do not appear anymore in the DFT.
They depend on the sample frequency $f_T$ and the number of samples $N$.
\begin{equation}
\Delta f = \frac{1}{N\cdot\Delta t} = \frac{f_T}{N}
\end{equation}
Where $\Delta t$ is distance between time samples and $\Delta f$
distance between frequency samples.

\addvspace{12pt}

With DFT the $N$ time samples are transformed into $N$ frequency samples.
This also holds if the time data are real numbers, as is always
the case in "real life": The complex frequency samples are conjugate
complex symmetrical and so equalizing the score:
\begin{equation}
\underline{U}_{N-n} = \underline{U}_n^*
\end{equation}

\addvspace{12pt}

That is, knowing the input data has no imaginary part, only half of
the Fourier data must be computed.

\addvspace{12pt}

As can be seen in equation \ref{eqn:DFT} the computing time of the
DFT rises with $N^2$. This is really huge. Because this transformation
must be performed many times during harmonic balance simulation, it is
very important to reduce the time consumption. Using a strongly
optimized algorithm, the so-called Fast Fourier Transformation (FFT),
the DFT is reduced to an $N\cdot\log_2 N$ time rise.
The following information stems from \cite{Press},
where the theoretical background is explained comprehensively.

\addvspace{12pt}

The fundamental trick of the FFT is to cut the DFT into two parts,
one with data having even indexes and the other with odd indexes:

\begin{eqnarray}
\underline{U}_n & = &
  \sum_{k=0}^{N-1} u_k\cdot \exp\left( -j\cdot n\frac{2\pi\cdot k}{N} \right) \\
  & = & \sum_{k=0}^{N/2-1} u_{2k}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot 2k}{N} \right) +
        \sum_{k=0}^{N/2-1} u_{2k+1}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot (2k+1)}{N} \right) \\
  & = & \underbrace{ \sum_{k=0}^{N/2-1} u_{2k}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot k}{N/2} \right) }_{F_{even}} +
        W_{n,N}\cdot \underbrace{ \sum_{k=0}^{N/2-1} u_{2k+1}\cdot
        \exp\left( -j\cdot n\frac{2\pi\cdot k}{N/2} \right) }_{F_{odd}} \\
\text{with} & & W_{n,N} = \exp\left( 2\pi\cdot j\cdot \frac{k}{N} \right)
\end{eqnarray}

The new formula shows no speed advantages. The important thing is that
the even as well as the odd part each is again a Fourier series. Thus
the same procedure can be repeated again and again until the equation
consists of $N$ terms. Then, each term contains only one data $u_k$
with factor $e^0=1$. This works if the number of data is a power of
two (2, 4, 8, 16, 32, ...).
So finally, the FFT method performs $\log_2 N$ times the operation
\begin{equation}
\label{eqn:FFTstep}
u_{k1,even} + W_{n,x}\cdot u_{k2,odd}
\end{equation}

to get one data of $\underline{U}_n$. This is called the
Danielson-Lanzcos algorithm.
The question now arises which data values of $u_k$
needs to be combined according to equation \ref{eqn:FFTstep}.
The answer is quite easy. The data array must be reordered by the
bit-reversal method. This means the value at index $k_1$ is swapped
with the value at index $k_2$ where $k_2$ is obtained by mirroring
the binary number $k_1$, i.e. the most significant bit becomes the
least significant one and so on. Example for $N=8$:

\addvspace{12pt}

\begin{tabular}{ccccccccccc}
000 & $\leftrightarrow$ & 000  & \qquad\qquad &  011 & $\leftrightarrow$ & 110  & \qquad\qquad &  110 & $\leftrightarrow$ & 011 \\
001 & $\leftrightarrow$ & 100  & \qquad\qquad &  100 & $\leftrightarrow$ & 001  & \qquad\qquad &  111 & $\leftrightarrow$ & 111 \\
010 & $\leftrightarrow$ & 010  & \qquad\qquad &  101 & $\leftrightarrow$ & 101 \\
\end{tabular}

\addvspace{12pt}

Having this new indexing, the values to combine according to
equation \ref{eqn:FFTstep} are the adjacent values. So, performing
the Danielson-Lanzcos algorithm has now become very easy.

\addvspace{12pt}

Figure \ref{fig:fft} illustrates the whole FFT algorithm starting with the
input data $u_k$ and ending with one value of the output data
$\underline{U}_n$.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=13cm]{fft}
\end{center}
\caption{principle of a FFT with data length 8}
\label{fig:fft}
\end{figure}
\FloatBarrier

Finally, a complete FFT source code should be presented. It was taken
from \cite{Press} and contains only a
few changes. (The function \texttt{SWAP(X, Y)} exchanges the values in
\texttt{X} and \texttt{Y}.)

\addvspace{12pt}

Parameters:\\
\begin{tabular}{lcl}
\texttt{num}    & - & number of complex samples\\
\texttt{data[]} & - & array containing the data samples,\\
                &   & real and imaginary part in alternating order (length: 2*\texttt{num})\\
\texttt{isign}  & - & is 1 to calculate FFT and -1 to calculate inverse FFT
\end{tabular}

\addvspace{12pt}

\texttt{ \\
>\quad // bit reversal method \\
>\quad int i, j, m, n; \\
>\quad n = 2*num; \\
>\quad j = 0; \\
>\quad for (i=0; i<n; i+=2) \{ \\
>\quad \qquad if(j > i) \{   // was index already swapped ? \\
>\quad \qquad\qquad SWAP(data[j], data[i]);   // swap real part \\
>\quad \qquad\qquad SWAP(data[j+1], data[i+1]);   // swap imaginary part \\
>\quad \qquad \} \\
>\quad \qquad m = n/2; \\
>\quad \qquad while (m >= 2 \&\& j >= m) \{  // calculate next swap index \\
>\quad \qquad\qquad j -= m; \\
>\quad \qquad\qquad m >>= 1; \\
>\quad \qquad \} \\
>\quad \qquad j += m; \\
>\quad \} \\
>\quad \\
>\quad // Danielson-Lanzcos algorithm \\
>\quad int mmax, istep; \\
>\quad double wtemp, theta, wr, wi, wpr, wpi, tempi, tempr; \\
>\quad mmax = 2; \\
>\quad while (n > mmax) \{ \\
>\quad \qquad istep = mmax << 1; \\
>\quad \qquad theta = isign * (2*pi/mmax); \\
>\quad \qquad wtemp = sin(0.5*theta); \\
>\quad \qquad wpr = -2.0*wtemp*wtemp; \\
>\quad \qquad wpi = sin(theta); \\
>\quad \qquad wr = 1.0; \\
>\quad \qquad wi = 0.0; \\
>\quad \qquad for (m=1; m<mmax; m+=2) \{ \\
>\quad \qquad\qquad for (i=m; i<=n; i+=istep) \{ \\
>\quad \qquad\qquad\qquad j = i+mmax; \\
>\quad \qquad\qquad\qquad tempr = wr*data[j-1] - wi*data[j]; \\
>\quad \qquad\qquad\qquad tempi = wr*data[j] + wi*data[j-1]; \\
>\quad \qquad\qquad\qquad data[j-1] = data[i-1] - tempr; \\
>\quad \qquad\qquad\qquad data[j] = data[i] - tempi; \\
>\quad \qquad\qquad\qquad data[i-1] += tempr; \\
>\quad \qquad\qquad\qquad data[i] += tempi; \\
>\quad \qquad\qquad \} \\
>\quad \qquad\qquad wr = (wtemp=wr)*wpr - wi*wpi + wr; \\
>\quad \qquad\qquad wi = wi*wpr + wtemp*wpi + wi; \\
>\quad \qquad \} \\
>\quad \qquad mmax = istep; \\
>\quad \}
}

\addvspace{12pt}

There are many other FFT algorithms mainly aiming at higher speed.
Two that are worth mentioning are base-4 FFT (about 20\% faster)
and the Winograd Fourier transform algorithm (up to 100\% faster).
However, the algorithms are much more complex.

\addvspace{12pt}

A standard Fourier Transformation is not useful in harmonic balance
methods, because with multi-tone excitation many mixing products appear.
The best way to cope with this problem is to use multi-dimensional
FFT.

\addvspace{12pt}

Fourier Transformations in more than one dimension soon become
very time consuming. Using FFT mechanisms is therefore mandatory.
A more-dimensional Fourier Transformation consists of many
one-dimensional Fourier Transformations (1D-FFT). First, 1D-FFTs
are performed for the data of the first dimension at every index
of the second dimension. The results are used as input data for
the second dimension that is performed the same way with respect
to the third dimension. This procedure is continued until all
dimensions are calculated. The following equations shows this
for two dimensions.

\begin{eqnarray}
\underline{U}_{n1,n2} & = & \sum_{k_2=0}^{N_2-1} \sum_{k_1=0}^{N_1-1}
   u_{k_1,k_2}\cdot \exp\left( -j\cdot n_1\frac{2\pi\cdot k_1}{N_1} \right)
              \cdot \exp\left( -j\cdot n_2\frac{2\pi\cdot k_2}{N_2} \right) \\
 & = & \sum_{k_2=0}^{N_2-1} \exp\left( -j\cdot n_2\frac{2\pi\cdot k_2}{N_2} \right)
       \cdot \underbrace{ \sum_{k_1=0}^{N_1-1}
   u_{k_1,k_2}\cdot \exp\left( -j\cdot n_1\frac{2\pi\cdot k_1}{N_1} \right) }_\text{1D-FFT}
\end{eqnarray}


Finally, a complete $n$-dimensional FFT source code should be
presented. It was taken from \cite{Press}.

\addvspace{12pt}

Parameters:\\
\begin{tabular}{lcl}
\texttt{ndim}   & - & number of dimensions\\
\texttt{num[]}  & - & array containing the number of complex samples for every dimension\\
\texttt{data[]} & - & array containing the data samples,\\
                &   & real and imaginary part in alternating order (length: 2*sum of \texttt{num[]}),\\
                &   & going through the array, the first dimension changes least rapidly !\\
                &   & all subscripts range from 1 to maximum value !\\
\texttt{isign}  & - & is 1 to calculate FFT and -1 to calculate inverse FFT
\end{tabular}

\addvspace{12pt}

\texttt{ \\
>\quad int idim, i1, i2, i3, i2rev, i3rev, ip1, ip2, ip3, ifp1, ifp2; \\
>\quad int ibit, k1, k2, n, nprev, nrem, ntot; \\
>\quad double tempi, tempr, wtemp, theta, wr, wi, wpi, wpr; \\
>\quad \\
>\quad ntot = 1; \\
>\quad for (idim=1; idim<=ndim; idim++) // compute total number of complex values \\
>\quad \qquad ntot *= num[idim]; \\
>\quad \\
>\quad nprev = 1; \\
>\quad for (idim=ndim; idim>=1; idim--) \{ // main loop over the dimensions \\
>\quad \qquad n = num[idim]; \\
>\quad \qquad nrem = ntot/(n*nprev); \\
>\quad \qquad ip1 = nprev << 1; \\
>\quad \qquad ip2 = ip1*n; \\
>\quad \qquad ip3 = ip2*nrem; \\
>\quad \qquad i2rev = 1; \\
>\quad \\
>\quad \qquad for (i2=1; i2<=ip2; i2+=ip1) \{ // bit-reversal method \\
>\quad \qquad\qquad if (i2 < i2rev) \{ \\
>\quad \qquad\qquad\qquad for (i1=i2; i1<=i2+ip1-2; i1+=2) \{ \\
>\quad \qquad\qquad\qquad\qquad for (i3=i1; i3<=ip3; i3+=ip2) \{ \\
>\quad \qquad\qquad\qquad\qquad\qquad i3rev = i2rev+i3-i2; \\
>\quad \qquad\qquad\qquad\qquad\qquad SWAP(data[i3],data[i3rev]); \\
>\quad \qquad\qquad\qquad\qquad\qquad SWAP(data[i3+1],data[i3rev+1]); \\
>\quad \qquad\qquad\qquad\qquad \} \\
>\quad \qquad\qquad\qquad \} \\
>\quad \qquad\qquad \} \\
>\quad \qquad\qquad ibit=ip2 >> 1; \\
>\quad \qquad\qquad while (ibit >= ip1 \&\& i2rev > ibit) \{ \\
>\quad \qquad\qquad\qquad i2rev -= ibit; \\
>\quad \qquad\qquad\qquad ibit >>= 1; \\
>\quad \qquad\qquad \} \\
>\quad \qquad\qquad i2rev += ibit; \\
>\quad \qquad \} \\
>\quad \\
>\quad \qquad ifp1 = ip1; \\
>\quad \qquad while (ifp1 < ip2) \{ // Danielson-Lanzcos algorithm \\
>\quad \qquad\qquad ifp2 = ifp1 << 1; \\
>\quad \qquad\qquad theta = isign*2*pi/(ifp2/ip1); \\
>\quad \qquad\qquad wtemp = sin(0.5*theta); \\
>\quad \qquad\qquad wpr = -2.0*wtemp*wtemp; \\
>\quad \qquad\qquad wpi = sin(theta); \\
>\quad \qquad\qquad wr = 1.0; wi = 0.0; \\
>\quad \qquad\qquad for (i3=1; i3<=ifp1; i3+=ip1) \{ \\
>\quad \qquad\qquad\qquad for (i1=i3; i1<=i3+ip1-2; i1+=2) \{ \\
>\quad \qquad\qquad\qquad\qquad for (i2=i1; i2<=ip3; i2+=ifp2) \{ \\
>\quad \qquad\qquad\qquad\qquad\qquad k1 = i2; \\
>\quad \qquad\qquad\qquad\qquad\qquad k2 = k1+ifp1; \\
>\quad \qquad\qquad\qquad\qquad\qquad tempr = wr*data[k2] - wi*data[k2+1]; \\
>\quad \qquad\qquad\qquad\qquad\qquad tempi = wr*data[k2+1] + wi*data[k2]; \\
>\quad \qquad\qquad\qquad\qquad\qquad data[k2] = data[k1] - tempr; \\
>\quad \qquad\qquad\qquad\qquad\qquad data[k2+1] = data[k1+1] - tempi; \\
>\quad \qquad\qquad\qquad\qquad\qquad data[k1] += tempr; data[k1+1] += tempi; \\
>\quad \qquad\qquad\qquad\qquad \} \\
>\quad \qquad\qquad\qquad \} \\
>\quad \qquad\qquad\qquad wr = (wtemp=wr)*wpr-wi*wpi+wr; \\
>\quad \qquad\qquad\qquad wi = wi*wpr+wtemp*wpi+wi; \\
>\quad \qquad\qquad \} \\
>\quad \qquad\qquad ifp1 = ifp2; \\
>\quad \qquad \} \\
>\quad \qquad nprev *= n; \\
>\quad \}
}


\section{A Symbolic HB Algorithm}

In this final section, a harmonic balance algorithm in symbolic language is
presented.

\addvspace{12pt}

\texttt{ \\
\begin{tabular}{ll}
>\quad init();                    & // separate linear and non-linear devices \\
>\quad Y = calcTransMatrix();     & // transimpedance matrix of linear circuit \\
>\quad I = calcSourceCurrent();   & // source current of linear subcircuit \\
>\quad (v, i, q) = calculateDC(); & // DC simulation as initial HB estimate \\
>\quad V = FFT(v);                & // transform voltage into frequency domain \\
>\quad & \\
>\quad loop: & \\
>\quad\quad I = FFT(i);                       & // current into frequency domain \\
>\quad\quad Q = FFT(q);                       & // charge into frequency domain \\
>\quad\quad E = I + Y*V + j*Omega*Q + I;      & // HB equation \\
>\quad\quad if (abs(E) < Eterm)  return;      & // convergence reached ? \\
>\quad\quad JG = mFFT(GJacobian(v, i));       & // create Jacobians and transform... \\
>\quad\quad JQ = mFFT(QJacobian(v, i));       & // ... them into frequency domain \\
>\quad\quad J = Y + j*Omega*JQ + JG;          & // calculate overall Jacobian \\
>\quad\quad V = V - invert(J) * Error;        & // Newton Raphson iteration step \\
>\quad\quad v = IFFT(V);                      & // voltage into time domain \\
>\quad\quad i = nonlinearCurrent(v);          & // use component models to get... \\
>\quad\quad q = nonlinearCharge(v);           & // ... values for next iteration \\
>\quad\quad goto loop; & \\
\end{tabular}
}


\section{Large-Signal S-Parameter Simulation}

Using harmonic balance techniques, it is also possible to perform
an S-parameter simulation in the large-signal regime. This is called
LSSP (large-signal s-parameter). Figure \ref{fig:lssp} shows the
principle. The port $n$ excites the circuit with the simulation
frequency $f_0$; meanwhile the power of all other ports is set to
zero. Having voltage and current of the fundamental frequency $f_0$
at the ports, the S-parameters can be calculated:

\begin{equation}
\label{eqn:ui2s}
\underline{S}_{mn} = \frac{\underline{U}_m(f_0) - \underline{I}_m(f_0)\cdot Z_m}
                          {\underline{U}_n(f_0) + \underline{I}_n(f_0)\cdot Z_n}
		\cdot \sqrt{\frac{Z_n}{Z_m}}
\end{equation}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=7cm]{lssp}
\end{center}
\caption{S-parameter from AC voltages and currents}
\label{fig:lssp}
\end{figure}
\FloatBarrier

An algorithm in symbolic language should describe the whole LSSP:

\addvspace{12pt}

\texttt{>\quad for n=1 to $NumberOfPorts$ \{} \\
\texttt{>\quad \qquad Set power of port $n$ to $P_n$.} \\
\texttt{>\quad \qquad Set power of ports $\ne n$ to 0.} \\
\texttt{>\quad \qquad Perform Harmonic Balance.} \\
\texttt{>\quad \qquad } \\
\texttt{>\quad \qquad for m=1 to $NumberOfPorts$} \\
\texttt{>\quad \qquad \qquad Calculate $\underline{S}_{mn}$ according to equation \ref{eqn:ui2s}.} \\
\texttt{>\quad }\}
